---
layout: post
title: "Analyzing Multi‑Stage Detection Evasion Chains in Lab Environments"
date: 2025-12-16
categories: red-teaming cybersecurity
---

## Overview

This article explores common detection evasion techniques observed in lab environments.

## Voice Transcript (Corrected)

We have gotten very close to comprehensive attack chains from what has been known by a Chinese advanced threat actor who has weaponized a technique called Bring Your Own Vulnerability. The cybersecurity or simple SOC analyst tool made by Rapid7, Velociraptor, has a vulnerability called CVE-2025-6264, and this allows you to run commands as SYSTEM, hidden as a Velociraptor Query Language (VQL) artifact. Basically, it's kind of like a saved query, but it could also be used via exec environment variable to launch malicious commands. Through this ability to launch as administrator, let's go through this, you can now load a first-stage loader in via PowerShell that spawns a PowerShell window as administrator, inject an AMSI hook or any AMSI bypass techniques to it via remote thread injection so you can continue running malicious PowerShell, .NET, or C# commands and scripts without being stopped by Anti-Malware Scan Interface.

Through this opening, you can actually install the r77 rootkit from a 64-bit PowerShell process by using a stub that's commonly found in Metasploit Framework, which allows you to transition from Heaven’s Gate style—a 32-bit to 64-bit, from 64-bit shellcode back to 32-bit. It's actually in their migrate code and it's open source. So once you persist yourself via an r77 rootkit, you can use your Cloudflare Pages and Workers to collect credentials while continuously executing ransomware kernel exploits that are also using dynamic invoke to execute DLL shellcode.

The reason why we want them as DLLs is because in this PowerShell window that we're constantly injecting into, when you use a simple API call, like GetProcessId, the DLL data is injected or loaded into the PowerShell process, it automatically gets the process ID of its host process, which is the PowerShell window. So I wrote a simple loader in C, and then I recompiled it as a DLL, and this is now dynamically invoked in PowerShell. And then from PowerShell, it spawns a second-stage PowerShell window, which is then injected with kernel exploits, which elevates it and gives it Protected Process Light (PPL) permission, so it can't be scanned by antivirus. It bypasses Anti-Malware Scan Interface permanently. It leverages the Velociraptor exploit to escalate privileges to administrator, which allows that kernel exploit to work because you can't exploit a vulnerable driver without being administrator in the first place.

Once you get kernel-level privileges and add Protected Process Light to yourself in the PowerShell process, you can execute even more evil things, like malware, Cobalt Strike beacons, and the victim cannot see it. So I just tested it this morning and it actually works very well. I'm going to be taking this voiceover and adding it to an Excalidraw graph to explain the whole attack chain.

On top of that, another trick you can use is creating barriers. So previously, I talked about my virtual machine obfuscator, right? And a virtual machine obfuscator has two full machines: a stack machine and a state machine. So a stack machine emulates things like registers, the virtual stack, the virtual instruction pointer, the virtual stack pointer, and the state machine switches on and off when to exit a function—for example, virtual machine, call the virtualized function, and then it ends the state and exits the function with a virtual machine exit. So using this trick and then turning the virtualized malware into a DLL and then calling shellcode Reflective DLL Injection to inject into PowerShell via dynamic invocation, you now create two layers.

So first, the analyst must remove Protected Process from the invisible PowerShell process, alright, which is now hidden by a rootkit. Does that make sense? Because it's hiding powershell.exe, cmd.exe, conhost.exe, the original malware. And then once they turn off the kernel exploit, remove the driver, delete the exploit, reboot the machine, they need to look for the rootkit, kill the rootkit, then they have to dump the hidden PowerShell process, which is now revealed as a process ID, right? And from that process ID, they need to attach to a debugger, get past the anti-debugging code that I added, and they dump the DLL because it's the unmapped DLL. It's an injected DLL. It's not in the module linked list. Once they dump the DLL, which will have legitimate DLL shellcode, so it's still shellcode. You've got to run the Blob Runner from OALabs or make your own shellcode runner and then break through it. You now have to crack the virtual machine. And if you don't know the virtual machine, you don't know what it does statically, and through dynamic analysis, you're in another layer of hell. So you can maintain very powerful attack campaigns persistently.

## Addendum Transcript:

So to clarify, and this is just for the actual demonstration video, the reason why I started the process PowerShell suspended is because I wanted to beat the race condition, all right? As soon as a process starts up, it will inherit amsi.dll, but if you start up suspended while AMSI is still there, once it reaches the main entry point, I have a pre-injected, basically a private unmapped DLL as shellcode into PowerShell.

And because I manually hooked that DLL, my AMSI hook automatically hooks anytime the real Anti-Malware Scan Interface calls AmsiScanBuffer, then I will always evaluate all my malicious commands as true. So it has nothing to do with beating EDR. You need more to beat EDR. Specifically, you need hopefully a Guard Page hook with Vectored Exception Handler, right?

And through that, you can automatically—let me see—you can automatically hook calls to ntdll.dll and it will intercept all of the calls for CreateProcess or NtCreateProcess, CreateProcess, or NtAllocateVirtualMemory, whatever it is through every DLL you inject. So any malicious command that you run in PowerShell windows, it gets intercepted and then uses direct or indirect syscalls. Okay, so that's...

### Key Notes

- All demonstrations are conducted in isolated lab setups.
- Historical techniques are discussed for defensive research purposes.
- Modern detection systems have mitigations that address these techniques.

